import { useState, useEffect } from 'react'
import { collection, addDoc, updateDoc, doc, query, where, getDocs, orderBy, Timestamp } from 'firebase/firestore'
import { db } from '@/integrations/firebase/client'
import { useAuth } from '@/contexts/FirebaseAuthContext'

export interface RecurrenceRule {
  id?: string
  taskId: string
  originalTaskId: string
  frequency: 'daily' | 'weekly' | 'monthly' | 'yearly'
  interval: number // Every X days/weeks/months/years
  endDate?: string
  maxOccurrences?: number
  createdAt: string
  updatedAt: string
}

export interface RecurringTask {
  id: string
  title: string
  description?: string
  priority: number // 1-10 scale
  dueDate: string
  assigneeIds: string[]
  projectId?: string
  status: 'todo' | 'in_progress' | 'completed' | 'cancelled'
  recurrence?: RecurrenceRule
  isRecurring: boolean
  parentTaskId?: string // Reference to original task
  userId: string
  createdAt: string
  updatedAt: string
}

export const useFirebaseRecurrence = () => {
  const { user } = useAuth()
  const [recurringTasks, setRecurringTasks] = useState<RecurringTask[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  // Create a recurring task
  const createRecurringTask = async (taskData: Partial<RecurringTask>, recurrenceRule: Omit<RecurrenceRule, 'id' | 'taskId' | 'originalTaskId' | 'createdAt' | 'updatedAt'>) => {
    if (!user) throw new Error('User not authenticated')

    try {
      const now = new Date().toISOString()
      
      // Create the original task
      const originalTask = {
        ...taskData,
        userId: user.uid,
        isRecurring: true,
        createdAt: now,
        updatedAt: now,
        priority: taskData.priority || 5, // Default priority 5
      }

      const taskRef = await addDoc(collection(db, 'tasks'), originalTask)

      // Create the recurrence rule
      const recurrenceData = {
        ...recurrenceRule,
        taskId: taskRef.id,
        originalTaskId: taskRef.id,
        createdAt: now,
        updatedAt: now,
      }

      const recurrenceRef = await addDoc(collection(db, 'recurrenceRules'), recurrenceData)

      // Update the task with recurrence info
      await updateDoc(taskRef, {
        recurrence: {
          id: recurrenceRef.id,
          ...recurrenceData
        }
      })

      return { taskId: taskRef.id, recurrenceId: recurrenceRef.id }
    } catch (err) {
      console.error('Error creating recurring task:', err)
      throw err
    }
  }

  // Generate next occurrence of a recurring task
  const generateNextOccurrence = async (completedTaskId: string) => {
    try {
      // Get the completed task
      const taskQuery = query(collection(db, 'tasks'), where('id', '==', completedTaskId))
      const taskSnapshot = await getDocs(taskQuery)
      
      if (taskSnapshot.empty) {
        throw new Error('Task not found')
      }

      const completedTask = taskSnapshot.docs[0].data() as RecurringTask
      
      if (!completedTask.recurrence) {
        throw new Error('Task is not recurring')
      }

      // Check if we should create the next occurrence
      const shouldCreateNext = checkIfShouldCreateNext(completedTask.recurrence)
      if (!shouldCreateNext) {
        return null
      }

      // Calculate next due date
      const nextDueDate = calculateNextDueDate(completedTask.dueDate, completedTask.recurrence)
      
      // Create the next occurrence
      const nextTask = {
        ...completedTask,
        id: '', // Will be generated by Firestore
        dueDate: nextDueDate,
        status: 'todo' as const,
        parentTaskId: completedTask.parentTaskId || completedTask.id,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      }

      // Remove the recurrence field from the new task (it's only on the original)
      delete nextTask.recurrence

      const nextTaskRef = await addDoc(collection(db, 'tasks'), nextTask)

      // Update recurrence rule
      await updateDoc(doc(db, 'recurrenceRules', completedTask.recurrence.id), {
        taskId: nextTaskRef.id,
        updatedAt: new Date().toISOString(),
      })

      return nextTaskRef.id
    } catch (err) {
      console.error('Error generating next occurrence:', err)
      throw err
    }
  }

  // Check if we should create the next occurrence
  const checkIfShouldCreateNext = (recurrence: RecurrenceRule): boolean => {
    const now = new Date()
    
    // Check end date
    if (recurrence.endDate && new Date(recurrence.endDate) <= now) {
      return false
    }

    // Check max occurrences (would need to track this in the recurrence rule)
    if (recurrence.maxOccurrences && recurrence.maxOccurrences <= 0) {
      return false
    }

    return true
  }

  // Calculate next due date based on recurrence rule
  const calculateNextDueDate = (currentDueDate: string, recurrence: RecurrenceRule): string => {
    const currentDate = new Date(currentDueDate)
    const interval = recurrence.interval || 1

    switch (recurrence.frequency) {
      case 'daily':
        currentDate.setDate(currentDate.getDate() + interval)
        break
      case 'weekly':
        currentDate.setDate(currentDate.getDate() + (interval * 7))
        break
      case 'monthly':
        currentDate.setMonth(currentDate.getMonth() + interval)
        break
      case 'yearly':
        currentDate.setFullYear(currentDate.getFullYear() + interval)
        break
    }

    return currentDate.toISOString()
  }

  // Get all recurring tasks for a user
  const getRecurringTasks = async () => {
    if (!user) return

    try {
      setLoading(true)
      const tasksQuery = query(
        collection(db, 'tasks'),
        where('userId', '==', user.uid),
        where('isRecurring', '==', true),
        orderBy('createdAt', 'desc')
      )
      
      const snapshot = await getDocs(tasksQuery)
      const tasks = snapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data()
      })) as RecurringTask[]

      setRecurringTasks(tasks)
    } catch (err) {
      console.error('Error fetching recurring tasks:', err)
      setError('Failed to fetch recurring tasks')
    } finally {
      setLoading(false)
    }
  }

  // Update a recurring task
  const updateRecurringTask = async (taskId: string, updates: Partial<RecurringTask>) => {
    try {
      const taskRef = doc(db, 'tasks', taskId)
      await updateDoc(taskRef, {
        ...updates,
        updatedAt: new Date().toISOString()
      })
    } catch (err) {
      console.error('Error updating recurring task:', err)
      throw err
    }
  }

  // Delete a recurring task and its recurrence rule
  const deleteRecurringTask = async (taskId: string) => {
    try {
      // Get the task to find its recurrence rule
      const taskQuery = query(collection(db, 'tasks'), where('id', '==', taskId))
      const taskSnapshot = await getDocs(taskQuery)
      
      if (!taskSnapshot.empty) {
        const task = taskSnapshot.docs[0].data() as RecurringTask
        
        // Delete the recurrence rule if it exists
        if (task.recurrence?.id) {
          await updateDoc(doc(db, 'recurrenceRules', task.recurrence.id), {
            deleted: true,
            updatedAt: new Date().toISOString()
          })
        }
      }

      // Delete the task
      await updateDoc(doc(db, 'tasks', taskId), {
        deleted: true,
        updatedAt: new Date().toISOString()
      })
    } catch (err) {
      console.error('Error deleting recurring task:', err)
      throw err
    }
  }

  useEffect(() => {
    if (user) {
      getRecurringTasks()
    }
  }, [user])

  return {
    recurringTasks,
    loading,
    error,
    createRecurringTask,
    generateNextOccurrence,
    updateRecurringTask,
    deleteRecurringTask,
    getRecurringTasks
  }
}
